package gvprojects.chess.model;

/**
 * Parent Chess Piece class that implements IChessPiece Interface that contains
 * general methods and helpers for checking isValidMove with rows, columns, and
 * diagonal.
 * 
 * @author rohrj
 * @version March 10, 2013
 */
public class ChessPiece implements IChessPiece {
	private Player player;
	private String name;
	private Move move;
	private IChessPiece[][] board;

	/**
	 * Constructor that takes player and a string as the name for the piece.
	 * 
	 * @param p
	 *            the player black or white
	 * @param str
	 *            the piece name
	 */
	public ChessPiece(Player p, String str) {
		player = p;
		name = str;
	}

	/**
	 * 
	 * @return true or false if it is a valid move
	 */
	public boolean isValidMove(Move m, IChessPiece[][] p) {

		if (m.fromRow < 0 || m.fromRow > 7 || m.fromColumn > 7
				|| m.fromColumn < 0)
			throw new IllegalArgumentException("Invalid Move Spots");
		else if (p[m.fromRow][m.fromColumn] != this
				|| p[m.fromRow][m.fromColumn].player() != this.player)
			throw new IllegalArgumentException(
					"Piece is not there or is not yours");
		else if (m.fromRow == m.toRow && m.toColumn == m.fromColumn)
			return false;
		else if (p[m.toRow][m.toColumn] != null
				&& p[m.fromRow][m.fromColumn] != null
				&& p[m.toRow][m.toColumn].player() == p[m.fromRow][m.fromColumn]
						.player())
			return false;
		else
			return true;
	}

	public String name() {
		return name;
	}

	public Player player() {
		return player;
	}

	protected boolean checkRandC(Move m, IChessPiece[][] p) {
		return ((m.fromRow != m.toRow && checkRow(m, p)) || (m.toColumn != m.fromColumn && checkCol(
				m, p)));
	}

	private boolean checkRow(Move m, IChessPiece[][] p) {
		if (p[m.toRow][m.toColumn] != null
				&& p[m.toRow][m.toColumn].player() == p[m.fromRow][m.fromColumn]
						.player())
			return false;
		// Checks from your position to the spot before your move to be empty
		if (m.fromRow < m.toRow) {
			for (int x = m.fromRow + 1; x < m.toRow; x++)
				if (p[x][m.fromColumn] != null)
					return false;
		} else
			for (int x = m.fromRow - 1; x > m.toRow; x--)
				if (p[x][m.fromColumn] != null)
					return false;

		return true;
	}

	private boolean checkCol(Move m, IChessPiece[][] p) {
		if (p[m.toRow][m.toColumn] != null
				&& p[m.toRow][m.toColumn].player() == p[m.fromRow][m.fromColumn]
						.player()) {
			System.out.println("False");
			return false;
		}
		// Checks from your position to the spot before your final spot to be
		// empty
		if (m.fromColumn < m.toColumn) {
			for (int y = m.fromColumn + 1; y < m.toColumn; y++)
				if (p[m.fromRow][y] != null)
					return false;

		} else
			for (int y = m.fromColumn - 1; y > m.toColumn; y--)
				if (p[m.fromRow][y] != null)
					return false;

		return true;
	}

	protected boolean checkDistance(Move m, int i) {
		if (m.fromColumn != m.toColumn
				&& (m.toColumn - m.fromColumn > i || m.fromColumn - m.toColumn > i)
				|| m.fromRow != m.toRow
				&& (m.toRow - m.fromRow > i || m.fromRow - m.toRow > i))
			return false;
		else
			return true;
	}

	protected boolean checkDiag(Move m, IChessPiece[][] p) {
		move = m;
		board = p;
		int a = 0, b = 0;
		if (m.fromRow - m.toRow > 0 && m.fromColumn - m.toColumn > 0) {
			a = -1;
			b = -1;
		} else if (m.fromRow - m.toRow > 0 && m.fromColumn - m.toColumn < 0) {
			a = -1;
			b = 1;
		} else if (m.fromRow - m.toRow < 0 && m.fromColumn - m.toColumn < 0) {
			a = 1;
			b = 1;
		} else if (m.fromRow - m.toRow < 0 && m.fromColumn - m.toColumn > 0) {
			a = 1;
			b = -1;
		}
		return checkDiagHelp(m.fromRow + a, m.fromColumn + b, a, b);
	}

	private boolean checkDiagHelp(int x, int y, int a, int b) {

		if (x < 0 || x > 7 || y < 0 || y > 7)
			return false;
		else if (x == move.toRow && y == move.toColumn)
			return true;
		else if (board[x][y] != null)
			return false;
		else
			return checkDiagHelp(x + a, y + b, a, b);
	}
}
